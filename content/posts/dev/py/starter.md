---
title: "Python 起步"
date: 2022-06-15T00:58:24+08:00
draft: true
tags: ["python"]
summary: python 快速起步
---

## Part 1 变量与序列

在一个程序里，变量是最核心的部分，它表示了数据在程序中的流动和变化。

### 1.1 变量声明与赋值

如下表达式，"=" 为赋值符号，等式左边为变量名称，右边为赋予变量的值。

{{< hint warning >}}
**注意**  
变量名称不能以数字开头，不能包含空格，不能是诸如 `if else and not for` 等关键词
{{< /hint >}}

常规赋值

```py
a = 1
b = 2
c = True
d = "Hello"
```

连续赋值

```py
e = f = 12
```

[元组](#123-元组)赋值

```py
g, h = 3, 6
```

### 1.2 序列

在 Python 中一共有四种序列，可以用来表示一系列的值

1. 列表（List）是一种有序且可更改的集合，允许重复的元素。
2. 字典（Dictionary）是一个无序，可变和有索引的集合，没有重复的元素。
3. 元组（Tuple）是一种有序且不可更改的集合，允许重复的元素。
4. 集合（Set）是一个无序且无索引的集合，没有重复的元素。

<!-- TODO 增删查改四个类型的能力 -->

#### 1.2.1 列表

列表是 Python 中非常常用的序列表示，可以通过如下方法创建列表

```py
alist = [1, 2, 3, 4, 5, 6]
blist = ["a", "b", "c", "d"]
```

**新增**

```py
# 在列表的末尾新增一个数据
alist.append(7)
# 输出： [1, 2, 3, 4, 5, 6, 7]

# 在列表某个位置插入数据，第一个参数是位置，第二个参数是要插入的值
alist.insert(0, 0)
# 输出： [0, 1, 2, 3, 4, 5, 6, 7]
```

**删除**

```py
# 删除位置3的元素，del是python的关键字，作用是删除某个变量
del alist[3]
# 输出： [0, 1, 2, 4, 5, 6, 7]

# 删除列表中的值是2的元素，如果有多个值为2，那么删掉靠前的一个
alist.remove(2)
# 输出： [0, 1, 4, 5, 6, 7]
```

**取值**

因为列表是有序的，所以可以按照顺序对列表中的元素取值

```py
# 使用方括号操作符对列表变量进行索引，获取此位置的值
alist[0]
# 输出： 1

# 使用冒号可以提取某个范围的值得到另一个列表
alist[1:3]
# 输出： [2, 3, 4]

# 冒号前后都可以省略比如
alist[1:] # 表示提取从第一个开始一直到最后一个
# 输出： [2, 3, 4, 5, 6]
```

**修改**
赋值
```py
# 2号位置赋值为9
alist[2] = 9
# 输出： [0, 1, 9, 5, 6, 7]

```

#### 1.2.2 字典

字典是一种映射关系，由多个键值对（一对数据，反应名称到值的映射关系，就像是查字典一样，可以根据键名，查到相应的键值）组成，
通常用来创建一些特定结构的数据

```py
# 字典可定义一组有映射关系的数据
building = {
    'name': 'xx大楼',
    'type': '公建',
    'height': 99
}
```

字典虽然是无序的，但是列表是键值对的映射，所以可以通过索引键名取值，也可以赋值

```py
# 取值
building['name']
# 输出： xx大楼

# 修改
building['height'] = 72
```

```py
# 也可以直接设置一个新的键值对，值可以是任意类型，
# 这里将'levels'设置为一个列表，列表里有两个level
# 这里的level又是一个新的字典
building['levels'] = [
    {
        'name': 'L0',
        'height': 3
    },
    {
        'name': 'L1',
        'height': 4.5
    }
]
# 输出： {'name': 'xx大楼', 'type': '公建', 'height': 72, 'levels': [{'name': 'L0', 'height': 3}, {'name': 'L1', 'height': 4.5}]}
```

#### 1.2.3 元组

元组作为 Python 中有序不可更改的集合，虽然说用元组能实现的功能用列表也能做到，但是元组的特性，也给开发者带来不少便利。

上述变量赋值操作可以用元组赋值的方法，进行多个变量的赋值

```py
# 实际上就是创建了一个元组，包含两个元素，一个是1，一个是2，然后分别赋值给a，b
a, b = 1, 2

# 相当于是
c = 1, 2
a, b = c
```

```py

# 也可以两个以上的
t1 = 2, 4, 6
# 也可以是不同类型的
t2 = 'hi', True, 6, 7.5
```

{{< hint info >}}
**Tip**  
也就是说，在 Python 中，两个变量或者值，直接用逗号隔开，不用中括号表示的就是元组
{{< /hint >}}

因为元组是有序的，所以可以通过索引符号取值，但是不能为元组的某一项进行再一次赋值，不能删除，是只读的

```py
# 元组也可以通过索引符号取值
c[1]
# 输出： 2

# 但是不能赋值，如下表达式就是错误的，因为元组不可更改
c[1] = 3
```

#### 1.2.4 集合

集合是无序不重复序列，不可以通过索引取值，如下创建一个集合

```py
s1 = {1, 2, 4, 6, 3}
```

{{< hint info >}}
**Tip**  
也就是说，元组包上大括号就是集合了
{{< /hint >}}

由于集合 Set 中不能有重复的元素，所以在创建集合时的重复元素会被去掉，并且重新排序

```py
s2 = {2, 3, 1, 4, 3, 1, 6, 2}
# 输出： {1, 2, 3, 4, 6}
```

可以利用这个特性给列表元素去重，如果不在意顺序的话：

```py
list2 = ['a', 3, 1, 4, 3, 1, 6, 2]
# set(...)可以把列表变成集合
s3 = set(list2)
# list(...)可以把集合变成列表
list3 = list(s3)
# 输出： [1, 2, 3, 4, 6, 'a']
```

其中 [`set(...)`](https://docs.python.org/3/library/functions.html#func-set) 和 [`list(...)`](https://docs.python.org/3/library/functions.html#func-list) 是 Python 的内建功能，可用于不同类型数据之间的转换

## Part 2 函数与表达

**函数**思维是将数据间的某种**关系**表达出来，其实也是一种映射，相比于[字典](#122-字典)，函数的映射关系表达的是**过程**，
而字典可以看成函数的**输入**与**输出**的结果映射关系。

关键字 `def` 用于定义一个函数，如下：

### 2.1 定义函数

我们尝试定义一个求解一元二次方程实根的函数，已知，一元二次方程的根公式如下

{{< katex display >}}
x = {{-b \pm \sqrt {b^2 - 4ac}} \over 2a}
{{< /katex >}}

如公式所见，变量一共有三个，分别是 `a, b, c` 所以，这个函数会有三个参数，如下函数声明

```py
def f(a, b, c):
    delta = b**2 - 4 * a * c # 判别式
    sqrt_delta = delta ** 0.5 # 判别式的平方根
    return (-b + sqrt_delta) / 2*a, (-b - sqrt_delta) / 2*a # 以元组形式返回两个根

# 调用函数，传递参数
x = f(1, 2, -1)
```

上述函数定义了一个求解一元二次方程的函数，如下逐行解释：

1. 使用关键字`def`定义一个名为`f`的函数，参数有三个，分别是 `a, b, c` 作为变量传递到函数内部
2. 定义判别式`delta`，运算符`**`表示**幂运算**，运算符`*`表示**乘运算**，这一行就是公式{{< katex >}}\Delta = b^2 - 4ac{{< /katex >}}的表达式了，变量`delta`就表示判别式的值，
3. 定义变量`sqrt_delta`表示判别式的平方根，利用指数为`1 / 2`的幂运算表示
4. 以元组形式返回两个实根，`return`关键词仅在函数内部出现，用于给**调用函数**的表达式**赋值**，所用的值，在函数内叫**返回值**

{{< hint warning >}}
**注意**  
这里并没有写完，因为还没有根据判别式区分有没有实根的情况，此函数将在下文完善
{{< /hint >}}

### 2.2 代码块

- 代码块是一个程序的重要组成部分，很多语言都有代码块的概念，如上述函数`f(a, b, c)`就是一个代码块。
- Python 的代码块比较**特殊**，需要通过**缩进**的空格数量来区分，每`4`个空格为一个单位，用于区分代码块的级别。
- 通过一个单位的缩进代表这部分代码归函数`f(a, b, c)`所有，若后续代码不属于上一个块，需要把行前缩进调整到适当的位置，如后续函数调用`f(1, 2, -1)`

```py
# 定义函数f
def f(a, b, c):
····delta = b ** 2 - 4 * a * c # 判别式
····sqrt_delta = delta ** 0.5 # 判别式的平方根
····return (-b + sqrt_delta) / 2 * a, (-b - sqrt_delta) / 2 * a # 以元组形式返回两个根

# 调用函数，传递参数
f(1, 2, -1)
# 输出： (0.41421356237309515, -2.414213562373095)
```

{{< hint info >}}
**Tip**  
在大部分编辑器内，制表键`Tab`控制行向右一个单位的缩进，`Shift + Tab`控制行向左一个单位的缩进
{{< /hint >}}

### 2.3 注释

注释作为一个程序里可有可无的部分，真是让人又爱又恨。养成一个书写注释的习惯，可以方便与他人交流，或者是方便自己与未来的自己交流。
根据我的个人经验，未来的自己往往是不能一下子读懂现在的自己写的代码，所以千万记得写注释。注释有以下几种，使用哪种据情况而定。

{{< hint warning >}}
**Tips**  
在 Python 文件中写中文，需要在文件的首行增加一个特殊的注释`# -*- coding:utf8 -*-`，来告诉编译器，此文件的编码。
{{< /hint >}}

#### 2.3.1 单行注释

最常用，写在行末表明此行用意，写在变量上一行，标明变量用途，等等。以符号`#`开头，后面同行写的任何东西都不参与程序的执行。
这个单行注释，在前面的篇幅已经用过很多次了。

```py
# 调用函数，传递参数
f(1, 2, -1)

# 字典可定义一组有映射关系的数据
building = {
    'name': 'xx大楼',
    'type': '公建',
    'height': 99
}
```

#### 2.3.2 多行注释

多行注释一般用在文件开头，或者函数开头，用来表明文件或函数的用途。使用三个单引号，或者三个双引号包裹范围内的内容都是注释，可跨行。

```py
'''
这是一个简单的py程序
写着1+1等于几
'''

"""
就是想在这里写点儿字
还是跨行的
随便写
"""

def func():
    return 1 + 1
```

{{< details "扩展内容" >}}

#### 文档注释

文档注释和多行注释差不多一样，都是三个单引号，或者三个双引号，
开头的单引号加一个感叹号（可能只是[Doxygen](https://www.doxygen.nl/)的要求），
写的位置也不一样不一样。
比如说：

1. 写在文件开头，表明此文件属于哪个功能包，作者，创建时间等等。
2. 写在函数开头表明这个函数是什么功能，传递什么参数，返回什么样的值

文档注释，主要用于生成代码文档，方便阅读，生成文档的工具有很多种，在此就不赘述了。

```py
'''!
@package engine
@brief 一个非常厉害的算法
@file algo.py
@author KaivnD
@date 2022-06-15
'''

def f(a, b, c):
    """! 求解一元二次方程的实数根
    @param a   二次未知数的常数部分
    @param b   一次未知数的常数部分
    @param c   常数部分

    @return  根1,根2
    """
····delta = b ** 2 - 4 * a * c # 判别式
····sqrt_delta = delta ** 0.5 # 判别式的平方根
····return (-b + sqrt_delta) / 2 * a, (-b - sqrt_delta) / 2 * a # 以元组形式返回两个根
```

{{< /details >}}

## Part 3 流程与控制

我们写的大部分代码都是在描述流程，一个程序从开始到结束，变量在其中受流程语句的控制，有秩序的流动。
可以说，流程是一个程序的血管，而变量就是流淌在血液中的细胞。

### 3.1 条件判断 if...else...

条件判断可以根据变量的不同值，产生不同的运行路径，如上求一元二次方程的根，我们知道当**判别式**{{< katex >}}\Delta = b^2 - 4ac{{< /katex >}}大于等于`0`时，方程在实数范围内有解，所以，在这个函数内，我们需要区分**判别式**的不同情况，为函数返回不同的值，这就叫做条件判断，让我们来完善此函数

```py
def f(a, b, c):
····delta = b**2 - 4 * a * c # 判别式
····if delta > 0:
········# 此时方程有两个不相等的实根
········sqrt_delta = delta ** 0.5 # 判别式的平方根
········return (-b + sqrt_delta) / 2*a, (-b - sqrt_delta) / 2*a # 以元组形式返回两个根
····elif delta == 0:
········# 此时方程有两个相等的实根
········sqrt_delta = delta ** 0.5 # 判别式的平方根
········return (-b + sqrt_delta) / 2*a
····else:
········# 此时该方程在实数范围内无解，返回一个None代表无解
········return None
```

{{< hint info >}}
**Tip**
注意看每一行的缩进，这一次有两种缩进，一个是一个单位（4 个），另一个是两个单位（8 个）。由不同单位的缩进代表了，每一行代码属于的代码块，特别注意**冒号**的使用
{{< /hint >}}

{{< hint info >}}
**Tip**
此函数中`return` 语句代表函数已经执行完成，后续流程不在执行。
{{< /hint >}}

{{< details "扩展内容" >}}

#### 三元表达式

<!-- TODO 深化一下 -->

三元表达式可在简短的语句内完成有条件的变量声明，Python中没有和其他语言一样的三元表达式，但是有代替的写法，如下：

```py
# 变量number
number = 12
# number是奇数还是偶数，使用类似三元表达式来赋值
number_type = '偶数' if number % 2 == 0 else '奇数'
```

{{< hint info >}}
**Tip**
这里的三元表达式读成一句话就是，number_type的值是偶数如果number除以2的余数等于0的话，否则就是奇数
{{< /hint >}}

{{< / details >}}

### 3.2 循环遍历 for...

循环是一个很常用的流程，很多时候都需要重复的执行某些操作，比如：

#### 3.2.1 遍历等差数列

> [`range(...)`](https://docs.python.org/3/library/functions.html#func-range)函数
> Python 的一个内建功能，提供生成等差数列的功能

**函数签名**

> **range(stop)** 生成首项为 0，末项为 stop - 1 的等差数列，公差为 1

> **range(start, stop[, step])** 生成首项为 start，末项为 stop - 1 的等差数列，公差 step 为可选项，不填就是 1

> [`print(...)`](https://docs.python.org/3/library/functions.html#func-print)函数
> Python 的一个内建功能，可把变量的值输出到控制台查看

```py
for i in range(5):
    print(i)
"""
输出：
0
1
2
3
4
"""

for i in range(0, 4):
    print(i)
"""
输出：
0
1
2
3
"""

for i in range(0, 10, 2):
    print(i)
"""
输出：
0
2
4
6
8
"""
```

#### 3.2.2 遍历列表

遍历列表就是起一个变量，代表列表中的每一个元素，对元素进行操作。
如下程序，将a列表里不是偶数的放到b列表中

```py
a = [3, 5, 2, 6, 7, 9, 11, 23]
b = []
for item in a:
    # % 是求余数运算符，这里是把列表里的每一个数字都除以2，然后得到余数，若除以2的余数为零，代表能除尽，就是偶数
    if item % 2 != 0:
        b.append(item)

print(b)
# 输出：[3, 5, 7, 9, 11, 23]
```

其中，`for`代码块内的变量`item`就被看成是列表中的每一个元素

{{< details "扩展内容" >}}
#### 另一种写法
上述程序可用[列表解析](https://peps.python.org/pep-0202/)更简短的表达

```py
a = [3, 5, 2, 6, 7, 9, 11, 23]
b = [item for item in a if item % 2 != 0]
```
{{< /details >}}

有时候我们需要，同时遍历索引和值可以这么写：

```py
for i in range(len(a)):
    val = a[i]
    print(i, val)
'''
输出：
0 3
1 5
2 2
3 6
4 7
5 9
6 11
7 23
'''
```

> [`len(...)`](https://docs.python.org/3/library/functions.html#enumerate)函数
> Python 的一个内建功能，在这里是列表长度

{{< details "扩展内容" >}}
#### 另一种写法

```py
for i, val in enumerate(a):
    print(i, val)
# 和第一种写法效果一样
```

> [`enumerate(...)`](https://docs.python.org/3/library/functions.html#enumerate)函数
> Python 的一个内建功能，获取可迭代对象的迭代器，对于这里的列表而言，迭代器就是一个索引和值组成的元组
{{< /details >}}


#### 3.2.3 遍历字典

遍历字典和遍历列表类似，不过因为字典是多个键值对，情况稍微不太一样。

1. 如果按照列表的遍历来写的话，将只能遍历键

```py
building = {
    'name': 'xx大楼',
    'type': '公建',
    'height': 99
}

for item in building:
    # item 相当一是字典的每一个key
    print(item)
    # 可以通过索引操作符取值
    val = building[item]
"""
输出：
name
type
height
"""

# 相当于
for item in building.keys():
    print(item)
```

2. 要遍历值的话需要指明：

```py
for item in building.values():
    print(item)
"""
输出：
xx大楼
公建
99
"""
```

3. 遍历键值对

```py
for item in building.items():
    print(item)
"""
输出：
('name', 'xx大楼')
('type', '公建')
('height', 99)
"""
```
可以看出，这个item是个元组，那我们可以使用[元组赋值](#123-元组)的方式起两个变量：

```py
for key, val in building.items():
    print(key, val)
"""
输出：
name xx大楼
type 公建
height 99
"""
```

#### 3.2.4 跳过 continue

回到遍历数组那个例子，这里描述的是当`item`不是偶数的时候把item放到列表b里，
反过来就是，如果`item`是奇数，就**跳过**这次循环，**继续**下次循环，这就是`continue`，如下示例：

```py
a = [3, 5, 2, 6, 7, 9, 11, 23]
b = []
for item in a:
····if item % 2 == 0: continue
····b.append(item)

print(b)
# 输出：[3, 5, 7, 9, 11, 23]
```

所以`continue`继续的意思是继续**下一次循环**，一般我这么写是为了节省代码块，读起来更通顺。
特别是需要很多条件判断罗列、流程比较复杂的时候，这么写会更简短些。

#### 3.2.5 跳出 break

跳出和跳过是完全不一样的作用，跳出表示终止一层循环，比方说：
在一串字符中找到第一个字母`n`是字符串的第几个字母，如果找到了，后续的循环都是没有必要的，可以直接break
```py
words = 'Hi noah!'

index = -1

# 字符串可看作不可变有序的一种序列
for i in range(len(words)):
    letter = words[i]
    if letter == 'n':
        index = i
        break

if index > 0:
    # 拼接字符串，见扩展内容
    print('字母n在 ' + words + ' 中是第' + str(index) + '个字母')
else:
    print('没有在该字符串中找到字母n')

# 输出： 字母n在 Hi noah! 中是第3个字母
```

> [`str(...)`](https://docs.python.org/3/library/functions.html#func-str)函数
> Python 的一个内建功能，将变量转为字符串类型

{{< details "扩展内容" >}}
#### 字符串拼接
由于字符串可看作不可变有序的一种序列，所以可以使用`+`进行连接，单这种方式比较笨拙，容易阅读。
可用[Advanced String Formatting](https://peps.python.org/pep-3101/)，简化此过程。

```py
message = "字母n在 {} 中是第 {} 个字母".format(words, index) if index > 0 else '没有在该字符串中找到字母n'
print(message)
```

和上面的写法效果完全一样，推荐使用这种方法做字符串拼接
{{< /details >}}

### 3.3 条件循环 while...

`for` 循环一般用来做可遍历对象的遍历，当可遍历对象遍历完之后，循环就结束了。
`while` 循环是根据条件来循环，如果条件成立，将始终一遍一遍的循环下去，除非外力干扰。如：

```py
while True:
    print('never ends loop!')
```

`while`就是当条件满足的时候，执行while代码块，这类循环通常在当你需要在某个条件不满足时才停止的循环，或者不确定循环多少次的循环，比如：

```py

i = 0

while i < 6:
    # 加法赋值运算，见扩展内容
    i += 1
    print(i)
'''
输出：
1
2
3
4
5
6
'''
```

也可以写成
```py
i = 0
while True:
    i  += 1
    if i > 6:
        break
    print(i)
```

{{< details "扩展内容" >}}
#### Python赋值运算符

```py
i = 0
i += 1 # 相当于 i = i + 1，也就是说，旧的i值加1赋值给新的i
```

|符号|名称|
|:-:|:-:|
|=|赋值运算符|
|+=|加法赋值运算符|
|-=|减法赋值运算符|
|*=|乘法赋值运算符|
|/=|除法赋值运算符|
|%=|取模赋值运算符|
|**=|幂赋值运算符|
|//=|取整除赋值运算符|

{{< /details >}}

### 3.4 异常捕捉 try...except...

要说异常的捕捉得先说什么是异常，先倒回到求实数根函数，对于这个函数的设定，
是否有实根是可以通过判别式判断的，我们可以对这个函数进行设定，若无实根，认为是一种异常。如下所示：

```py
def f(a, b, c):
    delta = b**2 - 4 * a * c # 判别式
    if delta > 0:
        # 此时方程有两个不相等的实根
        sqrt_delta = delta ** 0.5 # 判别式的平方根
        return (-b + sqrt_delta) / 2*a, (-b - sqrt_delta) / 2*a # 以元组形式返回两个根
    elif delta == 0:
        # 此时方程有两个相等的实根
        sqrt_delta = delta ** 0.5 # 判别式的平方根
        return (-b + sqrt_delta) / 2*a
    else:
        # 设定，若无实根，认为是一种异常，那就不返回值，抛出一个异常
        raise Exception('输入条件无实根')
```

那么这个函数在被调用的时候，如果没有实根，则会直接抛出异常，退出整个程序。

```py
f(1, 2, 3)
'''
输出：
(base) kaivnd@KaivnDdeMacBook-Pro blog % python test.py
Traceback (most recent call last):
  File "test.py", line 15, in <module>
    f(1, 2, 3)
  File "test.py", line 13, in f
    raise Exception('输入条件无实根')
Exception: 输入条件无实根
'''
```

这个界面将会是大家日后经常会看到的，从最后一行的输出来看，正式我们在函数的末尾所抛出的异常。
`raise` 关键字用于抛出异常，`Exception`是一种异常。那么如何在明知函数会有异常的时候保证程序正常工作呢？
那就是要**捕捉异常**了

使用`try...except...`语句进行异常捕捉

```py
try:
    f(1, 2, 3)
except:
    print('这个f函数有异常，不太行，要处理一下这个函数遇到异常的情况。')

'''
输出：
(base) kaivnd@KaivnDdeMacBook-Pro blog % python test.py
这个f函数有异常，不太行，要处理一下这个函数遇到异常的情况。
'''
```

上述代码块仅是在找到异常的时候提个醒。通常，异常捕捉需要结合上下文来看，
比方说这里`try`内的流程是为了取到某个值，然后赋值给这个`try`代码块外的变量，
那么当遇到异常的时候，应该考虑使用另一种方法来，来计算这个值。

另，这个`except`部分并没有变量表示我们在f函数里抛出来的错误信息，我们可以这样来获取：

```py
try:
    f(1, 2, 3)
except Exception as err:
    print(err)
'''
输出：
(base) kaivnd@KaivnDdeMacBook-Pro blog % python test.py
输入条件无实根
'''
```

{{< details "扩展内容" >}}
#### 多种异常的捕捉

我们知道，二元一次方程，的第一元，二次方的常数部分如果是0的话，就相当于是一元一次方程了。
所以在这个函数的设定下，我们也可以认为a为0是一种异常

```py
def f(a, b, c):
    if a == 0:
        raise ValueError("a 不能为0")
    delta = b**2 - 4 * a * c # 判别式
    if delta > 0:
        # 此时方程有两个不相等的实根
        sqrt_delta = delta ** 0.5 # 判别式的平方根
        return (-b + sqrt_delta) / 2*a, (-b - sqrt_delta) / 2*a # 以元组形式返回两个根
    elif delta == 0:
        # 此时方程有两个相等的实根
        sqrt_delta = delta ** 0.5 # 判别式的平方根
        return (-b + sqrt_delta) / 2*a
    else:
        # 设定，若无实根，认为是一种异常，那就不返回值，抛出一个异常
        raise Exception('输入条件无实根')
```

这样的话在捕捉异常的时候就可以分清楚是哪种异常了。

```py
try:
    f(1, 2, 3)
except ValueError as ve:
    # 这个情况就是a为0了
    print(ve)
except Exception as e:
    # 这种情况就是没有实根
    print(e)
```

#### 完整形态

`try...except...`的完整形态其实是`try...except...else...finally...`

```py
try:
    f(1, 2, 3)
except:
    print('有异常')
else:
    print('没有异常')
finally:
    print('管你有没有异常都要执行')
```

#### with 语句

`with`语句使用来缩短`try...finally...`的语法。举个常用的例子，从硬盘读取要一个文件，通常需要这么写：

1. 不捕捉异常
```py
file = open("/path/to/file.txt")
data = file.read()
file.close()
```

2. 捕捉异常
```py
file = open("/path/to/file.txt")
try:
    data = file.read()
finally:
    file.close()
```

也就是说，我们通过python从硬盘里读取一个文件完毕后时需要调用close取关闭这个文件，告诉系统你对这个文件已经使用完了。
假设，在读取的过程遇到异常，如果使用第一种写法在执行到`file.read()`到时候直接抛出异常，那就以为着整个程序瞬间结束，
`file.close()`压根儿没有机会执行，所以你这时候使用我们刚学的知识，可以使用`try...finally...`管你遇不遇到异常，
都要执行这个`file.close()`，也就是说，就算在读取文件的时候遇到异常，文件也可以被正确关闭。但是这么写，太长了，太复杂，
所以就有了`with`，如下，使用`with`来写：

```py
with open("/path/to/file.txt") as f:
    content = f.read()
```

> 简短且安全的完成文件读取
{{< /details >}}

## Part 4 对象与模块

使用抽象思维建立一些模块可以使得程序变得更容易阅读，充分分离各个功能组团，可以使代码复用率提升。
有效的模块封装可以让自己写的功能更容易在多个项目中使用，同时也可以在社区获取别的大神所创造的功能，
丰富的功能模块，使得Python更强大。

### 4.1 面对对象编程

**面对对象编程**是一种**抽象**思维，通常和**面对过程编程**做比较，本文从开头到此都是面对过程的编程，
直接从过程入手，通过流程控制变量的数据流动，完成指定功能。这两种编程思维没有优劣之分，相辅相成。
**面对对象编程**的思想用于宏观思考，组织架构，**面对过程编程**的思想即可用解决宏观架构下的微观问题，
又可以辅助建立宏观框架。

#### 4.1.1 模版

**抽象**是一个核心思维，让我们回到先前提到的[字典的例子](#122-字典)，这就是一个典型的抽象思维，
我们在这里定义了一个建筑物的数据结构，他有名称，类型，高度，楼层等信息，这就可以看作是一个对象，
而名称，类型，高度，楼层等信息是这个对象的基本属性。

```py
building = {
    'name': 'xx大楼',
    'type': '公建',
    'height': 99,
    'levels': [
        {
            'name': 'L0',
            'height': 3
        },
        {
            'name': 'L1',
            'height': 4.5
        }
    ]
}
```

如果我们能确定这些基本属性的值，那么也就确定了一个建筑物：

1. 这些基本属性的集合可以称为创建一个建筑物的模版，也可以叫做一个**类（Class）**
2. 通过这些属性的值得到的建筑物叫做**对象**，也可以叫做**实例**
3. 把值代进去创建一个建筑物的过程叫**实例化**
4. 每一个属性都是这个类的**成员**，这里的名称，类型，高度，楼层都是变量，所以又叫做**成员变量**或者**成员属性**

下面我们用Python把这个模版表示出来：

```py
# 声明一个名为Building的class
class Building:
    '''
    定义构造函数，实例化的时候将会被调用，函数也是类的成员。
    第一个参数为形参，必须要带，只有带上这个形参，才是成员函数，名字无所谓，通常写成self，表示自己
    第二个参数为名称，是自己加的，想加什么参数就可以加什么参数，加的参数需要在实例化的时候填值，表示这栋楼的名称
    第三个参数类型，表示建筑类型
    '''
    def __init__(self, name, buildingt_type):
        # 构造函数内需要对属性进行初始化，可以从构造参数传递，也可以直接赋值
        self.name = name
        #通过.操作符，可以用访问self的成员
        self.type = buildingt_type
        self.levels = []

    '''
    定义一个增加楼层的方法（函数），class的成员函数一般被称为方法，
    这个方法，用来增加一个楼层，将会改变levels成员的值
    '''
    def addLevel(self, name, height):
        self.levels.append((name, height))

    '''
    定义一个方法来获取这栋楼的高度，因为楼的高度是随着楼层的改变而改变，
    所以这个成员的值是与别的变量有相关性的。所以使用一个函数来计算，
    函数头上有一个修饰符@property用来说明这个height成员是一个计算属性，
    而不是一个方法。
    '''
    @property
    def height(self):
        # 定义一个变量储存高度信息
        height = 0

        # 遍历每一个楼层
        for level in self.levels:
            # 把楼层高度通过加法赋值累加到height变量
            height += level[1]
        
        # 返回所有楼层高度之和
        return height
```

#### 4.1.2 对象

上述模版仅仅只是规定了`Building`这个对象长什么样，相当于是一个**模具**，需要拿到生产线加工才能得到**对象**。

1. 案例A
```py
# 起一个变量名为building，构造一个名称为xx大楼，类型为公建的Building的实例
building = Building("xx大楼", "公建")
# 调用building的addLevel方法为Building增加一层名为L0，高度为4.5的楼层
building.addLevel("L0", 4.5)
# 调用building的addLevel方法为Building增加一层名为L1，高度为3的楼层
building.addLevel("L1", 3)

# 获取building的高度
print(building.height)
# 输出：4.5
```

2. 案例B
```py
# 起一个名为buildings的空列表
buildings = []

for i in range(10):
    name = "#" + str(i + 1)
    building = Building(name, "多层")

    # 第二层循环用于给每一个building增加一定数量的楼层
    for j in range(6):
        level = "L" + str(j)
        building.addLevel(level, 3)

    buildings.append(building)

# 这样以来，就可以有一系列的建筑物储存在一个列表当中
for building in buildings:
    print("{}楼", building)
```

### 4.2 模块
